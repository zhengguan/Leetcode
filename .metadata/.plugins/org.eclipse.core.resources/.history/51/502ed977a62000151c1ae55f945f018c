// Leetcode 145	
// Binary Tree Postorder Traversal
// Given a binary tree, return the postorder traversal of its nodes' values.
// https:// leetcode.com/problems/binary-tree-postorder-traversal/		
// 
// For example:
// Given binary tree {1,#,2,3},
//    1
//     \
//      2
//     /
//    3
// return [3,2,1].
// 
// Note: Recursive solution is trivial, could you do it iteratively?

import tester.Tester;

import java.util.*;

/**
 * Definition for a binary tree node.
 */

// Definition 1:
// A Tree is either:
// 	-- null
// 	-- (Int Tree Tree)

// Definition 2:
// A Tree is either:
// 	-- (Int null null)
// 	-- (Int Tree null)
// 	-- (Int null Tree)
// 	-- (Int Tree Tree)

class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode(int x) { val = x; }
}
 
public class Solution {
    List<Integer> treeTraversal; 
    
    public List<Integer> postorderTraversal(TreeNode root) {
    	treeTraversal = new ArrayList<Integer>();
        postorderTraversalRecur(root);
//        postorderTraversalIter(root);
        return treeTraversal;
    }
    

    public void postorderTraversalRecur(TreeNode root) {
    	if(root == null) {
    		return;
    	}
    	else {
    		postorderTraversalRecur(root.left);
    		postorderTraversalRecur(root.right);
    		treeTraversal.add(root.val);
    		return;
    	}
    }
    
    // This is wrong !!!!
//    public void postorderTraversalIter(TreeNode root) {   	
//    	if(root == null) {
//    		return;
//    	}
//    	else {
//    		// What's the meaning of stack ???
//        	ArrayList<TreeNode> stack = new ArrayList<TreeNode>();
//    		stack.add(root);   		
//    		ArrayList<Integer> modes = new ArrayList<Integer>();
//    		modes.add(0);
//    		while(!stack.isEmpty()) {
//    			TreeNode node = stack.get(stack.size()-1);
//    			if(node == null) {
//    				continue;
//    			}
//    			else {
//    				
//    			}
//    		}
//    		return;
//    	}
//    }
    
    public void sortColors(int[] nums) {
        int start = 0;
        int end = nums.length;
        while(start < end)
        //@loop_invariant all elements in nums[0, start) equal to 0;
        //@loop_invariant all elements in nums[end, nums.length) equal to 1 or 2;
        {
            if(nums[start] == 0) {
                start++;
            }
            else {
                //@assert nums[start2] == 1 || nums[start2] == 2;
                swap(nums, start, end - 1);
                end--;
            }
        }
        //@assert start == end;
        int start2 = start;
        int end2 = nums.length;
        while(start2 < end2)
        //@loop_invariant all elements in nums[start, start2) equal to 1;
        //@loop_invariant all elements in nums[end2, nums.length) equal to 2;
        {
            if(nums[start2] == 1) {
                start2++;
            }
            else{
                //@assert nums[start2] == 2;
                swap(nums, start2, end2 - 1);
                end2--;

            }
        }
        return;
    }
    
    public void swap(int[] nums, int i, int j) {
    	int tmp = nums[i];
    	nums[i] = nums[j];
    	nums[j] = tmp;
    }
}

class SolutionExamples {
	Solution s = new Solution();
	
	// tests for method postorderTraversal()
	boolean testPostorderTraversal(Tester t) {
		TreeNode[] tns = new TreeNode[8];
		for(int i = 0; i < 8; i++) {
			tns[i] = new TreeNode(i);
		}
		for(int i = 1; i < 4; i++) {
			tns[i].left = tns[i * 2];
			tns[i].right = tns[i * 2 + 1];
		}		
		System.out.println(s.postorderTraversal(tns[6].left));
		System.out.println(s.postorderTraversal(tns[6]));
		System.out.println(s.postorderTraversal(tns[1]));
		return
		true;
	}
	
	boolean isSorted(int[] nums) {
		for(int i = 0; i < nums.length - 1; i++) {
			if(nums[i] > nums[i+1]) {
				return false;
			}
		}
		return true;
	}
	
	boolean testSortColor(Tester t) {
		int[] nums = new int[] {1,1,0,0,2,0,1,0,1};
		s.sortColors(nums);
		System.out.println(this.isSorted(nums));
		return true;
	}
}
// Leetcode 188
// Best Time to Buy and Sell Stock IV
// https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/

// Say you have an array for which the ith element is the price of a given stock 
// on day i.
// 
// Design an algorithm to find the maximum profit. You may complete at most k 
// transactions.
// 
// Note:
// You may not engage in multiple transactions at the same time (ie, you must 
// sell the stock before you buy again).

import tester.Tester;

public class Solution {
    public int maxProfit(int k, int[] prices) {
    	if(k <= 0) {
    		return 0;
    	}
    	else {
            return maxProfitFrom(0, k, prices);    		
    	}
    }
    
    // WHERE: 0 <= start
    // RETURNS: the maximum profit can get from day start to the last day with
    // at most k transaction
    public int maxProfitFrom(int start, int k, int[] prices) {
    	if(prices.length - start < 2) {
    		return 0;
    	}
    	else {
    		//@assert 0 <= start && start <= prices.length - 2;
    		int profit = 0;
    		int minPrice = prices[start];
    		for(int i = start + 1; i < prices.length; i++) 
    		//@loop_invariant start < i && i <= prices.length;
    		/*@loop_invariant minPrices equal to the minimum element in 
    			prices[start, i) @*/
    		/*@loop_invariant profit represents the maximum profit can get 
    		   if the first transaction is finished before the ith day
    		 @*/
    		{
    			profit = Math.max(profit, 
    					prices[i] - minPrice 
    					+ this.maxProfitFrom(i + 1, k - 1, prices));
    			minPrice = Math.min(minPrice, prices[i]);
    		}
    		return profit;
    	}
    }
}

class SolutionExamples {
	Solution s = new Solution();
	
	// tests for method maxProfit()
	boolean testMaxProfit(Tester t) {
		return
		t.checkExpect(s.maxProfit(0, new int[]{1, 2}), 0) &&
		t.checkExpect(s.maxProfit(1, new int[]{1, 2}), 1) &&
		t.checkExpect(s.maxProfit(2, new int[]{2, 1}), 0) &&
		t.checkExpect(s.maxProfit(2, new int[]{2, 1, 3}), 2) &&
		t.checkExpect(s.maxProfit(1, new int[]{2, 1, 2, 4}), 3) &&
		t.checkExpect(s.maxProfit(1, new int[]{1, 2, 1, 2}), 1) &&
		t.checkExpect(s.maxProfit(2, new int[]{1, 2, 1, 2}), 2) &&
		t.checkExpect(s.maxProfit(2, new int[]{1, 2, 5, 4}), 4);
	}
}
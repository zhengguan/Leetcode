// Leetcode 123
// Best Time to Buy and Sell Stock III
// https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/

// Say you have an array for which the ith element is the price of a given stock 
// on day i.
// 
// Design an algorithm to find the maximum profit. You may complete as many 
// transactions as you like (ie, buy one and sell one share of the stock multiple
// times). However, you may not engage in multiple transactions at the same time 
// (ie, you must sell the stock before you buy again).

import tester.Tester;

public class Solution {
    public int maxProfit(int[] prices) {
    	if(prices.length == 0) {
    		return 0;
    	}
        return maxProfitFrom(prices, 0);
    }
    
    // GIVEN: an array whose ith element is the price of a given stock on day 
    // i and an int represents the start day
    // WHERE: 0 <= start && start <= prices.length; 
    // RETURNS: the maximum profit can get if start doing transaction from day
    // start
    public int maxProfitFrom(int[] prices, int start) {
    	if(prices.length - start <= 1) {
    		return 0;
    	}
    	else {
    		int profit = 0;
    		int minPrice = prices[0];
    		for(int i = start; i < prices.length; i++) 
    		//@loop_invariant minPrice equal to the minimum elements in prices[0, i)
    		/*@loop_invariant profit equal to the maximum profit can get if the
    			first sale has to be finished before the ith day @*/
    		//@loop_invariant 1 <= i;
    		{
    			profit = 
    					Math.max(profit, 
    							prices[i] - minPrice 
    							+ this.maxProfitFrom(prices, i + 1));
    			minPrice = Math.min(minPrice, prices[i]);
    		}
    		return profit;
    	}
    }
    
    // GIVEN: an array whose ith element is the price of a given stock on day 
    // i and an int represents the start day
    // WHERE: 0 <= start && start <= prices.length; 
    // RETURNS: the maximum profit can get if start doing transaction from day
    // start
    public int maxProfitIter(int[] prices) {
    	if(prices.length < 2) {
    		return 0;
    	}
    	else {
    		int[] minPrices = new int[prices.length];
    		minPrices[0] = prices[0];
    		for(int i = 1; i < prices.length; i++) 
    		//@loop_invariant 1 <= i;
    		/*@loop_invariant minPrices[i - 1] is equal to the minimum elements 
    		   of prices[0, i)  @*/
    		{
    			minPrices[i] = Math.min(minPrices[i - 1], prices[i]);
    		}
    		int[] profits = new int[prices.length];
    		for(int i = prices.length; i > 0; i--)
    		/*@loop_invariant 0 <= i;
    		/*@loop_invariant profits[i] represents the maximum profit can get
    			if start doing transaction in day i @*/
    		{
    			if(prices.length - (i - 1) < 2) {
    				profits[i - 1] = 0;
    			}
    			else {
    				profits[i - 1] = Math.max(0, 0);
    			}
    		}
    		
    		return 0;
    	}
    }
}


class SolutionExamples {
	Solution s = new Solution();
	
	// tests for method maxProfit()
	boolean testMaxProfit(Tester t) {
		return
		t.checkExpect(s.maxProfit(new int[]{1, 2}), 1) &&
		t.checkExpect(s.maxProfit(new int[]{1, 2, 1, 2}), 2) &&
		t.checkExpect(s.maxProfit(new int[]{1, 2, 5, 4}), 4);
	}
}

